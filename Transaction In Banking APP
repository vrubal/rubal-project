Isolation       | Safe for Banking? | Why
READ_COMMITTED  | ‚ùå               | Only prevents dirty reads. No real protection.
REPEATABLE_READ | ‚ö†Ô∏è Better        | Prevents dirty and non-repeatable reads. Still can have phantom problems.
SERIALIZABLE    | ‚úÖ Best          | Full isolation. No dirty reads, non-repeatable reads, lost updates, or phantoms.


‚ùó Why READ_COMMITTED is not enough

Problem                             | What Happens at READ_COMMITTED
üî• Lost Update                      | Two users read the same balance and overwrite each other's update.
üî• Non-repeatable Read              | Balance changes between reads inside the same transaction.
üî• No guarantee of real consistency | You can accidentally deduct more than available, or double credit.

[ API Layer (REST) ]
         ‚îÇ
         ‚ñº
[ Transaction Service ]
     - Start Transaction (DB tx)
     - Lock Accounts (SELECT FOR UPDATE)
     - Validate Balances
     - Perform Debit/Credit
     - Insert Ledger Entry
     - Commit
         ‚îÇ
         ‚ñº
[ Retry Layer (Optional) ]
     - If serialization failure (409 error)
     - Retry up to 3-5 times
         ‚îÇ
         ‚ñº
[ Event Publishing (Kafka/RabbitMQ) ]
     - "Money Moved" Event (for notifications, audit, downstream sync)
         ‚îÇ
         ‚ñº
[ Ledger DB ]
     - Final Immutable record (append-only)


Code Sample:

@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT a FROM Account a WHERE a.id = :id")
Optional<Account> findByIdForUpdate(@Param("id") Long id);


@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
    Account fromAccount = accountRepository.findByIdForUpdate(fromAccountId)
                                           .orElseThrow(() -> new RuntimeException("Account not found"));

    Account toAccount = accountRepository.findByIdForUpdate(toAccountId) // üî• Now locked too!
                                         .orElseThrow(() -> new RuntimeException("Account not found"));

    if (fromAccount.getBalance().compareTo(amount) < 0) {
        throw new RuntimeException("Insufficient balance");
    }

    fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
    toAccount.setBalance(toAccount.getBalance().add(amount));

    accountRepository.save(fromAccount);
    accountRepository.save(toAccount);
}

